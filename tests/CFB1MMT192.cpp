#include "rijndael.h"
#include "catch.hpp"
#include <cstring>

static inline std::string buf2str(const uint8_t *buf, size_t len) {
    std::ostringstream ss; ss << std::hex << std::setfill('0');
    for (size_t i = 0; i < len; ++i) {
        ss << std::setw(2) << static_cast<int>(buf[i]) << ' ';
    }
    return ss.str();
}

TEST_CASE("CFB1MMT192-ENCRYPT-0", "[CFB1][MMT][192][ENCRYPT][n0]") {
    const uint8_t KEY[] = { 0x09,0x38,0xb5,0x10,0xbb,0xef,0x65,0xbf,0xac,0x65,0x6e,0xa6,0x32,0x64,0x00,0x83,0x24,0x36,0xcf,0x8b,0xef,0x67,0xc3,0x54 };
    const uint8_t IV[] = { 0x4c,0x88,0xde,0x2b,0x07,0x17,0x2c,0x92,0x23,0x16,0x76,0x1e,0x82,0x2d,0xd7,0x4d };
    const uint8_t PLAINTEXT[] = { 0x1 };
    const uint8_t CIPHERTEXT[] = { 0x1 };
    aes_state state;
    uint8_t RESULT[sizeof(CIPHERTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_encrypt_cfb1(&state, PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == sizeof(CIPHERTEXT));
    CAPTURE(buf2str(CIPHERTEXT, sizeof(CIPHERTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-ENCRYPT-1", "[CFB1][MMT][192][ENCRYPT][n1]") {
    const uint8_t KEY[] = { 0xfd,0x6f,0x0b,0x8f,0x70,0x34,0xa2,0x58,0xa9,0x0b,0xd4,0xdd,0x07,0x68,0x95,0x52,0xbd,0x45,0x46,0xa6,0xd2,0x18,0xd8,0x10 };
    const uint8_t IV[] = { 0x65,0x8e,0xfb,0xec,0xa0,0x5b,0x50,0xed,0xd3,0x5c,0xc3,0x79,0xc5,0x08,0x78,0x6e };
    const uint8_t PLAINTEXT[] = { 0x00 };
    const uint8_t CIPHERTEXT[] = { 0x01 };
    aes_state state;
    uint8_t RESULT[sizeof(CIPHERTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_encrypt_cfb1(&state, PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == sizeof(CIPHERTEXT));
    CAPTURE(buf2str(CIPHERTEXT, sizeof(CIPHERTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-ENCRYPT-2", "[CFB1][MMT][192][ENCRYPT][n2]") {
    const uint8_t KEY[] = { 0xd5,0x8c,0x2e,0x65,0x1d,0xcd,0x68,0x03,0x9a,0x8d,0xbf,0x76,0x1f,0xa7,0xb6,0xfe,0x78,0x05,0xa0,0x78,0xa1,0x06,0x6e,0xe0 };
    const uint8_t IV[] = { 0xe6,0xe8,0x32,0xcf,0x3b,0x1d,0x32,0x32,0x25,0x66,0x83,0xfd,0xcc,0x9b,0xad,0x67 };
    const uint8_t PLAINTEXT[] = { 0x10,0x1 };
    const uint8_t CIPHERTEXT[] = { 0x11,0x1 };
    aes_state state;
    uint8_t RESULT[sizeof(CIPHERTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_encrypt_cfb1(&state, PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == sizeof(CIPHERTEXT));
    CAPTURE(buf2str(CIPHERTEXT, sizeof(CIPHERTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-ENCRYPT-3", "[CFB1][MMT][192][ENCRYPT][n3]") {
    const uint8_t KEY[] = { 0xba,0xa1,0x58,0xa1,0x6b,0x50,0x4a,0x10,0x8e,0xd4,0x33,0x2e,0xe7,0xf2,0x9b,0xf6,0xd1,0xac,0x46,0xa8,0xde,0x5a,0xfe,0x7a };
    const uint8_t IV[] = { 0x57,0xc6,0x89,0x7c,0x99,0x52,0x28,0x13,0xbf,0x67,0x9c,0xe1,0x13,0x70,0xaf,0x5e };
    const uint8_t PLAINTEXT[] = { 0x10,0x00 };
    const uint8_t CIPHERTEXT[] = { 0x00,0x11 };
    aes_state state;
    uint8_t RESULT[sizeof(CIPHERTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_encrypt_cfb1(&state, PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == sizeof(CIPHERTEXT));
    CAPTURE(buf2str(CIPHERTEXT, sizeof(CIPHERTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-ENCRYPT-4", "[CFB1][MMT][192][ENCRYPT][n4]") {
    const uint8_t KEY[] = { 0xe9,0xe5,0xfa,0xce,0x86,0x74,0x5b,0xc3,0xa5,0x62,0xef,0x29,0x46,0x3d,0x5d,0x21,0xde,0x3a,0x57,0xa0,0x58,0x27,0xc2,0x0a };
    const uint8_t IV[] = { 0x78,0x39,0xe7,0x7e,0x83,0x05,0xfb,0x17,0x7f,0x01,0x7f,0x65,0x3f,0xff,0x07,0x82 };
    const uint8_t PLAINTEXT[] = { 0x11,0x10,0x0 };
    const uint8_t CIPHERTEXT[] = { 0x11,0x10,0x1 };
    aes_state state;
    uint8_t RESULT[sizeof(CIPHERTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_encrypt_cfb1(&state, PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == sizeof(CIPHERTEXT));
    CAPTURE(buf2str(CIPHERTEXT, sizeof(CIPHERTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-ENCRYPT-5", "[CFB1][MMT][192][ENCRYPT][n5]") {
    const uint8_t KEY[] = { 0x94,0x26,0xb0,0x7c,0x4b,0xf8,0x97,0xf9,0x87,0x6f,0xec,0x04,0x7f,0x78,0x40,0x04,0xd1,0xc7,0xbf,0x7c,0xc7,0x11,0xa0,0xdd };
    const uint8_t IV[] = { 0x34,0x02,0x05,0x65,0xf9,0x52,0x7b,0x0c,0x25,0xa7,0x30,0x1f,0xa0,0x5e,0xd3,0x19 };
    const uint8_t PLAINTEXT[] = { 0x01,0x10,0x01 };
    const uint8_t CIPHERTEXT[] = { 0x01,0x11,0x11 };
    aes_state state;
    uint8_t RESULT[sizeof(CIPHERTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_encrypt_cfb1(&state, PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == sizeof(CIPHERTEXT));
    CAPTURE(buf2str(CIPHERTEXT, sizeof(CIPHERTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-ENCRYPT-6", "[CFB1][MMT][192][ENCRYPT][n6]") {
    const uint8_t KEY[] = { 0xe3,0xed,0x64,0xef,0x69,0xd8,0x6a,0xc8,0x61,0xaa,0x03,0x0c,0xa8,0xdb,0x99,0x0e,0x96,0x77,0xd9,0x57,0xde,0x71,0xb6,0x9c };
    const uint8_t IV[] = { 0x86,0x57,0x65,0x6b,0xb7,0xea,0x77,0x12,0x71,0xf0,0x0a,0xa8,0xfe,0x9c,0x57,0x16 };
    const uint8_t PLAINTEXT[] = { 0x10,0x00,0x00,0x1 };
    const uint8_t CIPHERTEXT[] = { 0x00,0x10,0x00,0x1 };
    aes_state state;
    uint8_t RESULT[sizeof(CIPHERTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_encrypt_cfb1(&state, PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == sizeof(CIPHERTEXT));
    CAPTURE(buf2str(CIPHERTEXT, sizeof(CIPHERTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-ENCRYPT-7", "[CFB1][MMT][192][ENCRYPT][n7]") {
    const uint8_t KEY[] = { 0x1a,0x70,0xf0,0x5a,0x08,0x2a,0x71,0x03,0xcd,0xe2,0x78,0xa2,0x12,0xea,0x1e,0xbf,0xd3,0x9c,0x5e,0x33,0x14,0x43,0x6f,0x30 };
    const uint8_t IV[] = { 0x4f,0xd0,0xec,0xac,0x65,0xbf,0xd3,0x21,0xc8,0x8e,0xbc,0xa0,0xda,0xea,0x35,0xd2 };
    const uint8_t PLAINTEXT[] = { 0x00,0x10,0x10,0x00 };
    const uint8_t CIPHERTEXT[] = { 0x01,0x10,0x01,0x00 };
    aes_state state;
    uint8_t RESULT[sizeof(CIPHERTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_encrypt_cfb1(&state, PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == sizeof(CIPHERTEXT));
    CAPTURE(buf2str(CIPHERTEXT, sizeof(CIPHERTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-ENCRYPT-8", "[CFB1][MMT][192][ENCRYPT][n8]") {
    const uint8_t KEY[] = { 0x76,0xd5,0x9e,0xc1,0x4f,0x74,0x8e,0xd1,0xc0,0x7d,0x9f,0x5b,0x2c,0x58,0xeb,0x21,0x1f,0xf6,0xed,0xc0,0x8d,0x08,0xe7,0x88 };
    const uint8_t IV[] = { 0xbc,0xa1,0x13,0xce,0x16,0xc0,0x6e,0xd1,0x16,0xef,0x97,0x71,0x1f,0x53,0x31,0x99 };
    const uint8_t PLAINTEXT[] = { 0x01,0x10,0x01,0x00,0x1 };
    const uint8_t CIPHERTEXT[] = { 0x00,0x10,0x00,0x00,0x0 };
    aes_state state;
    uint8_t RESULT[sizeof(CIPHERTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_encrypt_cfb1(&state, PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == sizeof(CIPHERTEXT));
    CAPTURE(buf2str(CIPHERTEXT, sizeof(CIPHERTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-ENCRYPT-9", "[CFB1][MMT][192][ENCRYPT][n9]") {
    const uint8_t KEY[] = { 0x7c,0xb6,0x26,0xaa,0x15,0x9f,0x92,0x32,0x5a,0x77,0x52,0x5a,0xea,0xf4,0x94,0xaa,0xfa,0x07,0xd6,0xb7,0x9a,0x0e,0x4b,0xf7 };
    const uint8_t IV[] = { 0x06,0x14,0x37,0x9d,0xeb,0xaa,0xe2,0x8e,0x84,0xe4,0x6f,0x7e,0x2f,0xb0,0xda,0x0a };
    const uint8_t PLAINTEXT[] = { 0x10,0x11,0x11,0x00,0x11 };
    const uint8_t CIPHERTEXT[] = { 0x10,0x00,0x10,0x10,0x11 };
    aes_state state;
    uint8_t RESULT[sizeof(CIPHERTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_encrypt_cfb1(&state, PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == sizeof(CIPHERTEXT));
    CAPTURE(buf2str(CIPHERTEXT, sizeof(CIPHERTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-DECRYPT-0", "[CFB1][MMT][192][DECRYPT][n0]") {
    const uint8_t KEY[] = { 0x1e,0xe9,0x42,0x38,0xc0,0x99,0xad,0xc8,0xe4,0xf9,0x68,0x44,0xa9,0x3e,0x28,0x9c,0x14,0xe3,0xc6,0x5a,0x56,0xe5,0x9d,0x78 };
    const uint8_t IV[] = { 0x3b,0x2a,0xe6,0x88,0xd3,0x52,0xe3,0x75,0x9b,0x89,0xcf,0x41,0xcc,0x76,0xc3,0x6b };
    const uint8_t PLAINTEXT[] = { 0x0 };
    const uint8_t CIPHERTEXT[] = { 0x1 };
    aes_state state;
    uint8_t RESULT[sizeof(PLAINTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_decrypt_cfb1(&state, CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == sizeof(PLAINTEXT));
    CAPTURE(buf2str(PLAINTEXT, sizeof(PLAINTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-DECRYPT-1", "[CFB1][MMT][192][DECRYPT][n1]") {
    const uint8_t KEY[] = { 0xb5,0x8e,0x86,0x80,0x9c,0x1c,0x52,0x00,0xb5,0x45,0xb8,0x69,0xe8,0xa3,0xfd,0xbf,0xba,0xf4,0xf5,0x54,0xc3,0xc0,0x19,0x8e };
    const uint8_t IV[] = { 0x85,0x6a,0xcc,0xe5,0x8a,0xbf,0xe5,0x95,0xcf,0x33,0xfc,0x31,0x92,0x5f,0x5a,0xb3 };
    const uint8_t PLAINTEXT[] = { 0x00 };
    const uint8_t CIPHERTEXT[] = { 0x00 };
    aes_state state;
    uint8_t RESULT[sizeof(PLAINTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_decrypt_cfb1(&state, CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == sizeof(PLAINTEXT));
    CAPTURE(buf2str(PLAINTEXT, sizeof(PLAINTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-DECRYPT-2", "[CFB1][MMT][192][DECRYPT][n2]") {
    const uint8_t KEY[] = { 0xf5,0x3d,0x9b,0x89,0x9a,0x0a,0x41,0xba,0xe3,0xda,0x14,0xb7,0xc9,0xcc,0x8a,0xb0,0x0f,0xae,0x08,0x06,0xde,0x14,0xa6,0x01 };
    const uint8_t IV[] = { 0xec,0x63,0x39,0xf5,0x3d,0x60,0xb1,0x7f,0x06,0x0e,0xcd,0xfe,0x4b,0x30,0xce,0x00 };
    const uint8_t PLAINTEXT[] = { 0x11,0x0 };
    const uint8_t CIPHERTEXT[] = { 0x11,0x0 };
    aes_state state;
    uint8_t RESULT[sizeof(PLAINTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_decrypt_cfb1(&state, CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == sizeof(PLAINTEXT));
    CAPTURE(buf2str(PLAINTEXT, sizeof(PLAINTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-DECRYPT-3", "[CFB1][MMT][192][DECRYPT][n3]") {
    const uint8_t KEY[] = { 0xfa,0x10,0xae,0x20,0x14,0xce,0x91,0x69,0xae,0xe6,0xd7,0x25,0x09,0x61,0xfa,0x3c,0x82,0xff,0x4d,0x06,0x1f,0x78,0x30,0xb0 };
    const uint8_t IV[] = { 0x52,0x3f,0xbc,0x67,0x32,0xe0,0x57,0x63,0x19,0xd6,0xb3,0xca,0xaf,0xf5,0xec,0x9d };
    const uint8_t PLAINTEXT[] = { 0x11,0x10 };
    const uint8_t CIPHERTEXT[] = { 0x11,0x00 };
    aes_state state;
    uint8_t RESULT[sizeof(PLAINTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_decrypt_cfb1(&state, CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == sizeof(PLAINTEXT));
    CAPTURE(buf2str(PLAINTEXT, sizeof(PLAINTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-DECRYPT-4", "[CFB1][MMT][192][DECRYPT][n4]") {
    const uint8_t KEY[] = { 0xdb,0x2c,0xfd,0xab,0xf0,0x25,0xa5,0x3b,0xe6,0x90,0xc3,0x03,0x6b,0xaa,0xb1,0xc4,0xc9,0xee,0x10,0x69,0xd1,0x36,0x60,0x47 };
    const uint8_t IV[] = { 0x86,0x9a,0x17,0x22,0x6d,0x74,0x1a,0xa3,0x87,0x93,0xba,0x16,0x7a,0x13,0x6b,0xaa };
    const uint8_t PLAINTEXT[] = { 0x10,0x11,0x0 };
    const uint8_t CIPHERTEXT[] = { 0x00,0x00,0x0 };
    aes_state state;
    uint8_t RESULT[sizeof(PLAINTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_decrypt_cfb1(&state, CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == sizeof(PLAINTEXT));
    CAPTURE(buf2str(PLAINTEXT, sizeof(PLAINTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-DECRYPT-5", "[CFB1][MMT][192][DECRYPT][n5]") {
    const uint8_t KEY[] = { 0xd0,0x88,0xd1,0x96,0x9a,0x01,0x24,0xa6,0x91,0xed,0x33,0x43,0x9d,0x60,0x51,0xc4,0xc9,0x0e,0xf2,0x1b,0x52,0x0e,0x63,0xb4 };
    const uint8_t IV[] = { 0x5b,0xd9,0x5b,0x97,0x8d,0xd8,0xdf,0xc3,0x1d,0x2b,0x23,0x86,0x6c,0xbd,0x32,0x4c };
    const uint8_t PLAINTEXT[] = { 0x00,0x11,0x10 };
    const uint8_t CIPHERTEXT[] = { 0x10,0x10,0x11 };
    aes_state state;
    uint8_t RESULT[sizeof(PLAINTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_decrypt_cfb1(&state, CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == sizeof(PLAINTEXT));
    CAPTURE(buf2str(PLAINTEXT, sizeof(PLAINTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-DECRYPT-6", "[CFB1][MMT][192][DECRYPT][n6]") {
    const uint8_t KEY[] = { 0x50,0x1d,0x2c,0x4d,0xf0,0x21,0xb1,0x47,0xa8,0x4a,0x82,0x31,0x0e,0xe7,0x7e,0xff,0x9c,0x9a,0x95,0x74,0x55,0x66,0x87,0xda };
    const uint8_t IV[] = { 0x06,0xf6,0x48,0x20,0xa6,0x9a,0x1b,0xaf,0x1a,0x12,0x70,0xb6,0x32,0x87,0x20,0xbb };
    const uint8_t PLAINTEXT[] = { 0x10,0x00,0x10,0x1 };
    const uint8_t CIPHERTEXT[] = { 0x01,0x00,0x00,0x1 };
    aes_state state;
    uint8_t RESULT[sizeof(PLAINTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_decrypt_cfb1(&state, CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == sizeof(PLAINTEXT));
    CAPTURE(buf2str(PLAINTEXT, sizeof(PLAINTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-DECRYPT-7", "[CFB1][MMT][192][DECRYPT][n7]") {
    const uint8_t KEY[] = { 0x38,0x0d,0x48,0x97,0x17,0x00,0xf8,0x29,0xb9,0x51,0xa0,0xa1,0x41,0x25,0x20,0x6e,0x36,0x77,0xd6,0x84,0x86,0x0d,0xc2,0xf7 };
    const uint8_t IV[] = { 0xf2,0x72,0x1e,0xc7,0x32,0x69,0x4e,0x38,0x1b,0x3d,0x65,0x70,0x36,0xde,0xea,0xec };
    const uint8_t PLAINTEXT[] = { 0x00,0x10,0x11,0x00 };
    const uint8_t CIPHERTEXT[] = { 0x01,0x01,0x11,0x11 };
    aes_state state;
    uint8_t RESULT[sizeof(PLAINTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_decrypt_cfb1(&state, CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == sizeof(PLAINTEXT));
    CAPTURE(buf2str(PLAINTEXT, sizeof(PLAINTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-DECRYPT-8", "[CFB1][MMT][192][DECRYPT][n8]") {
    const uint8_t KEY[] = { 0xcf,0x32,0x09,0xf1,0x9c,0x62,0xed,0x24,0xa5,0xa2,0x60,0x73,0x00,0xfd,0x50,0xe5,0x25,0x57,0x1e,0x26,0xa6,0x52,0xf4,0x86 };
    const uint8_t IV[] = { 0x3e,0x98,0xb7,0x48,0x7b,0x20,0xa8,0x16,0x66,0x9c,0xbc,0x89,0x48,0x84,0x97,0x7d };
    const uint8_t PLAINTEXT[] = { 0x00,0x00,0x00,0x01,0x0 };
    const uint8_t CIPHERTEXT[] = { 0x10,0x00,0x10,0x00,0x1 };
    aes_state state;
    uint8_t RESULT[sizeof(PLAINTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_decrypt_cfb1(&state, CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == sizeof(PLAINTEXT));
    CAPTURE(buf2str(PLAINTEXT, sizeof(PLAINTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == 0);
}

TEST_CASE("CFB1MMT192-DECRYPT-9", "[CFB1][MMT][192][DECRYPT][n9]") {
    const uint8_t KEY[] = { 0x87,0x3f,0x1e,0x63,0x1c,0xc8,0xee,0xeb,0xd9,0xce,0x5d,0x58,0xa6,0x72,0x9a,0x6d,0x46,0x32,0xb5,0x47,0x74,0xb2,0x56,0x40 };
    const uint8_t IV[] = { 0xbb,0x28,0x70,0x5e,0xf9,0xe5,0x15,0x1a,0xfc,0x73,0xe3,0x88,0x6f,0x25,0xf5,0x21 };
    const uint8_t PLAINTEXT[] = { 0x11,0x11,0x11,0x01,0x00 };
    const uint8_t CIPHERTEXT[] = { 0x01,0x01,0x11,0x11,0x01 };
    aes_state state;
    uint8_t RESULT[sizeof(PLAINTEXT)];
    REQUIRE(aes_init_iv(&state, KEY, 8 * sizeof KEY, IV));
    CAPTURE(buf2str(KEY, sizeof(KEY)));
    CAPTURE(buf2str(IV, sizeof(IV)));
    REQUIRE(aes_decrypt_cfb1(&state, CIPHERTEXT, RESULT, sizeof(CIPHERTEXT)) == sizeof(PLAINTEXT));
    CAPTURE(buf2str(PLAINTEXT, sizeof(PLAINTEXT)));
    CAPTURE(buf2str(RESULT, sizeof(RESULT)));
    REQUIRE(memcmp(PLAINTEXT, RESULT, sizeof(PLAINTEXT)) == 0);
}

